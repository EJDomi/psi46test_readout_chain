; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\Erich\Documents\College\DTB_project\psi46test-master\psi46test-master\usb.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?max_digits10@?$numeric_limits@D@std@@2HB	; std::numeric_limits<char>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_W@std@@2HB	; std::numeric_limits<wchar_t>::max_digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_N@std@@2HB	; std::numeric_limits<bool>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?max_digits10@?$numeric_limits@C@std@@2HB	; std::numeric_limits<signed char>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?max_digits10@?$numeric_limits@E@std@@2HB	; std::numeric_limits<unsigned char>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?max_digits10@?$numeric_limits@F@std@@2HB	; std::numeric_limits<short>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?max_digits10@?$numeric_limits@G@std@@2HB	; std::numeric_limits<unsigned short>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?max_digits10@?$numeric_limits@H@std@@2HB	; std::numeric_limits<int>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?max_digits10@?$numeric_limits@I@std@@2HB	; std::numeric_limits<unsigned int>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?max_digits10@?$numeric_limits@J@std@@2HB	; std::numeric_limits<long>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?max_digits10@?$numeric_limits@K@std@@2HB	; std::numeric_limits<unsigned long>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_J@std@@2HB	; std::numeric_limits<__int64>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_K@std@@2HB	; std::numeric_limits<unsigned __int64>::max_digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?value@?$integral_constant@I$0A@@tr1@std@@2IB	; std::tr1::integral_constant<unsigned int,0>::value
PUBLIC	?_Rank@?$_Arithmetic_traits@_N@std@@2HB		; std::_Arithmetic_traits<bool>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@D@std@@2HB		; std::_Arithmetic_traits<char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@C@std@@2HB		; std::_Arithmetic_traits<signed char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@E@std@@2HB		; std::_Arithmetic_traits<unsigned char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@F@std@@2HB		; std::_Arithmetic_traits<short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@G@std@@2HB		; std::_Arithmetic_traits<unsigned short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@H@std@@2HB		; std::_Arithmetic_traits<int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@I@std@@2HB		; std::_Arithmetic_traits<unsigned int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@J@std@@2HB		; std::_Arithmetic_traits<long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@K@std@@2HB		; std::_Arithmetic_traits<unsigned long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_J@std@@2HB		; std::_Arithmetic_traits<__int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_K@std@@2HB		; std::_Arithmetic_traits<unsigned __int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@M@std@@2HB		; std::_Arithmetic_traits<float>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@N@std@@2HB		; std::_Arithmetic_traits<double>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@O@std@@2HB		; std::_Arithmetic_traits<long double>::_Rank
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@O@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@O@std@@2HB DD 09H		; std::_Arithmetic_traits<long double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@N@std@@2HB DD 08H		; std::_Arithmetic_traits<double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@M@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@M@std@@2HB DD 07H		; std::_Arithmetic_traits<float>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_K@std@@2HB DD 06H		; std::_Arithmetic_traits<unsigned __int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_J@std@@2HB DD 06H		; std::_Arithmetic_traits<__int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@K@std@@2HB DD 05H		; std::_Arithmetic_traits<unsigned long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@J@std@@2HB DD 05H		; std::_Arithmetic_traits<long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@I@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@I@std@@2HB DD 04H		; std::_Arithmetic_traits<unsigned int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@H@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@H@std@@2HB DD 04H		; std::_Arithmetic_traits<int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@G@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@G@std@@2HB DD 03H		; std::_Arithmetic_traits<unsigned short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@F@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@F@std@@2HB DD 03H		; std::_Arithmetic_traits<short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@E@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@E@std@@2HB DD 02H		; std::_Arithmetic_traits<unsigned char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@C@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@C@std@@2HB DD 02H		; std::_Arithmetic_traits<signed char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@D@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@D@std@@2HB DD 02H		; std::_Arithmetic_traits<char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_N@std@@2HB DD 01H		; std::_Arithmetic_traits<bool>::_Rank
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@tr1@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@tr1@std@@2IB DD 00H	; std::tr1::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 08H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_K@std@@2HB DD 015H	; std::numeric_limits<unsigned __int64>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_J@std@@2HB DD 014H	; std::numeric_limits<__int64>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@K@std@@2HB DD 0bH	; std::numeric_limits<unsigned long>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@J@std@@2HB DD 0bH	; std::numeric_limits<long>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@I@std@@2HB DD 0bH	; std::numeric_limits<unsigned int>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@H@std@@2HB DD 0bH	; std::numeric_limits<int>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@G@std@@2HB DD 06H	; std::numeric_limits<unsigned short>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@F@std@@2HB DD 06H	; std::numeric_limits<short>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@E@std@@2HB DD 04H	; std::numeric_limits<unsigned char>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@C@std@@2HB DD 04H	; std::numeric_limits<signed char>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_N@std@@2HB DD 00H	; std::numeric_limits<bool>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_W@std@@2HB DD 06H	; std::numeric_limits<wchar_t>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@D@std@@2HB DD 04H	; std::numeric_limits<char>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 01H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
PUBLIC	??0CRpcError@@QAE@W4errorId@0@@Z		; CRpcError::CRpcError
; Function compile flags: /Ogtp
; File c:\users\erich\documents\college\dtb_project\psi46test-master\psi46test-master\rpc_error.h
;	COMDAT ??0CRpcError@@QAE@W4errorId@0@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
??0CRpcError@@QAE@W4errorId@0@@Z PROC			; CRpcError::CRpcError, COMDAT
; _this$ = ecx

; 33   : 	CRpcError(errorId e) : error(e) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR _e$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0CRpcError@@QAE@W4errorId@0@@Z ENDP			; CRpcError::CRpcError
_TEXT	ENDS
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_C@_0M@CBIEBGLO@other?5error?$AA@		; `string'
PUBLIC	??_C@_0O@NHEDABJP@not?5supported?$AA@		; `string'
PUBLIC	??_C@_0N@LBHEEELJ@invalid?5args?$AA@		; `string'
PUBLIC	??_C@_0BG@JMCJFOE@eeprom?5not?5programmed?$AA@	; `string'
PUBLIC	??_C@_0BD@JKEPJBHF@eeprom?5not?5present?$AA@	; `string'
PUBLIC	??_C@_0BE@CFCHMELH@eeprom?5erase?5failed?$AA@	; `string'
PUBLIC	??_C@_0BE@KJGDCNBK@eeprom?5write?5failed?$AA@	; `string'
PUBLIC	??_C@_0BD@HPOCEFDP@eeprom?5read?5failed?$AA@	; `string'
PUBLIC	??_C@_0BH@CBBLICLP@failed?5to?5write?5device?$AA@ ; `string'
PUBLIC	??_C@_0BM@NAGBLIJI@device?5not?5opened?5for?5write?$AA@ ; `string'
PUBLIC	??_C@_0BM@FOIECFGC@device?5not?5opened?5for?5erase?$AA@ ; `string'
PUBLIC	??_C@_0BC@JEMNCEK@invalid?5baud?5rate?$AA@	; `string'
PUBLIC	??_C@_0BC@GMEMBNHN@invalid?5parameter?$AA@	; `string'
PUBLIC	??_C@_0BG@JGELIADJ@insufficient?5resource?$AA@	; `string'
PUBLIC	??_C@_08GLNPIFBN@io?5error?$AA@			; `string'
PUBLIC	??_C@_0BC@HFCLPILE@device?5not?5opened?$AA@	; `string'
PUBLIC	??_C@_0BB@IHDJLKMG@device?5not?5found?$AA@	; `string'
PUBLIC	??_C@_0P@MNPFLEBL@invalid?5handle?$AA@		; `string'
PUBLIC	??_C@_02MFDMBIJM@ok?$AA@			; `string'
PUBLIC	?GetErrorMsg@CUSB@@SAPBDH@Z			; CUSB::GetErrorMsg
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
; File c:\users\erich\documents\college\dtb_project\psi46test-master\psi46test-master\usb.cpp
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CBIEBGLO@other?5error?$AA@
CONST	SEGMENT
??_C@_0M@CBIEBGLO@other?5error?$AA@ DB 'other error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NHEDABJP@not?5supported?$AA@
CONST	SEGMENT
??_C@_0O@NHEDABJP@not?5supported?$AA@ DB 'not supported', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LBHEEELJ@invalid?5args?$AA@
CONST	SEGMENT
??_C@_0N@LBHEEELJ@invalid?5args?$AA@ DB 'invalid args', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JMCJFOE@eeprom?5not?5programmed?$AA@
CONST	SEGMENT
??_C@_0BG@JMCJFOE@eeprom?5not?5programmed?$AA@ DB 'eeprom not programmed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JKEPJBHF@eeprom?5not?5present?$AA@
CONST	SEGMENT
??_C@_0BD@JKEPJBHF@eeprom?5not?5present?$AA@ DB 'eeprom not present', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CFCHMELH@eeprom?5erase?5failed?$AA@
CONST	SEGMENT
??_C@_0BE@CFCHMELH@eeprom?5erase?5failed?$AA@ DB 'eeprom erase failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KJGDCNBK@eeprom?5write?5failed?$AA@
CONST	SEGMENT
??_C@_0BE@KJGDCNBK@eeprom?5write?5failed?$AA@ DB 'eeprom write failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HPOCEFDP@eeprom?5read?5failed?$AA@
CONST	SEGMENT
??_C@_0BD@HPOCEFDP@eeprom?5read?5failed?$AA@ DB 'eeprom read failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CBBLICLP@failed?5to?5write?5device?$AA@
CONST	SEGMENT
??_C@_0BH@CBBLICLP@failed?5to?5write?5device?$AA@ DB 'failed to write dev'
	DB	'ice', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NAGBLIJI@device?5not?5opened?5for?5write?$AA@
CONST	SEGMENT
??_C@_0BM@NAGBLIJI@device?5not?5opened?5for?5write?$AA@ DB 'device not op'
	DB	'ened for write', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FOIECFGC@device?5not?5opened?5for?5erase?$AA@
CONST	SEGMENT
??_C@_0BM@FOIECFGC@device?5not?5opened?5for?5erase?$AA@ DB 'device not op'
	DB	'ened for erase', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JEMNCEK@invalid?5baud?5rate?$AA@
CONST	SEGMENT
??_C@_0BC@JEMNCEK@invalid?5baud?5rate?$AA@ DB 'invalid baud rate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GMEMBNHN@invalid?5parameter?$AA@
CONST	SEGMENT
??_C@_0BC@GMEMBNHN@invalid?5parameter?$AA@ DB 'invalid parameter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JGELIADJ@insufficient?5resource?$AA@
CONST	SEGMENT
??_C@_0BG@JGELIADJ@insufficient?5resource?$AA@ DB 'insufficient resource', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GLNPIFBN@io?5error?$AA@
CONST	SEGMENT
??_C@_08GLNPIFBN@io?5error?$AA@ DB 'io error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HFCLPILE@device?5not?5opened?$AA@
CONST	SEGMENT
??_C@_0BC@HFCLPILE@device?5not?5opened?$AA@ DB 'device not opened', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IHDJLKMG@device?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BB@IHDJLKMG@device?5not?5found?$AA@ DB 'device not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MNPFLEBL@invalid?5handle?$AA@
CONST	SEGMENT
??_C@_0P@MNPFLEBL@invalid?5handle?$AA@ DB 'invalid handle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02MFDMBIJM@ok?$AA@
CONST	SEGMENT
??_C@_02MFDMBIJM@ok?$AA@ DB 'ok', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GetErrorMsg@CUSB@@SAPBDH@Z
_TEXT	SEGMENT
_error$ = 8						; size = 4
?GetErrorMsg@CUSB@@SAPBDH@Z PROC			; CUSB::GetErrorMsg, COMDAT

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15   : 	switch (error)

  00003	8b 45 08	 mov	 eax, DWORD PTR _error$[ebp]
  00006	83 f8 12	 cmp	 eax, 18			; 00000012H
  00009	0f 87 8c 00 00
	00		 ja	 $LN20@GetErrorMs
  0000f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN24@GetErrorMs[eax*4]
$LN19@GetErrorMs:

; 16   : 	{
; 17   :     case FT_OK:                          return "ok";

  00016	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02MFDMBIJM@ok?$AA@

; 38   : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN18@GetErrorMs:

; 18   :     case FT_INVALID_HANDLE:              return "invalid handle";

  0001d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0P@MNPFLEBL@invalid?5handle?$AA@

; 38   : }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
$LN17@GetErrorMs:

; 19   :     case FT_DEVICE_NOT_FOUND:            return "device not found";

  00024	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BB@IHDJLKMG@device?5not?5found?$AA@

; 38   : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN16@GetErrorMs:

; 20   :     case FT_DEVICE_NOT_OPENED:           return "device not opened";

  0002b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@HFCLPILE@device?5not?5opened?$AA@

; 38   : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN15@GetErrorMs:

; 21   :     case FT_IO_ERROR:                    return "io error";

  00032	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08GLNPIFBN@io?5error?$AA@

; 38   : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN14@GetErrorMs:

; 22   :     case FT_INSUFFICIENT_RESOURCES:      return "insufficient resource";

  00039	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BG@JGELIADJ@insufficient?5resource?$AA@

; 38   : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN13@GetErrorMs:

; 23   :     case FT_INVALID_PARAMETER:           return "invalid parameter";

  00040	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@GMEMBNHN@invalid?5parameter?$AA@

; 38   : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN12@GetErrorMs:

; 24   :     case FT_INVALID_BAUD_RATE:           return "invalid baud rate";

  00047	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@JEMNCEK@invalid?5baud?5rate?$AA@

; 38   : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN11@GetErrorMs:

; 25   :     case FT_DEVICE_NOT_OPENED_FOR_ERASE: return "device not opened for erase";

  0004e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BM@FOIECFGC@device?5not?5opened?5for?5erase?$AA@

; 38   : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN10@GetErrorMs:

; 26   :     case FT_DEVICE_NOT_OPENED_FOR_WRITE: return "device not opened for write";

  00055	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BM@NAGBLIJI@device?5not?5opened?5for?5write?$AA@

; 38   : }

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN9@GetErrorMs:

; 27   :     case FT_FAILED_TO_WRITE_DEVICE:      return "failed to write device";

  0005c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BH@CBBLICLP@failed?5to?5write?5device?$AA@

; 38   : }

  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
$LN8@GetErrorMs:

; 28   :     case FT_EEPROM_READ_FAILED:          return "eeprom read failed";

  00063	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BD@HPOCEFDP@eeprom?5read?5failed?$AA@

; 38   : }

  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN7@GetErrorMs:

; 29   :     case FT_EEPROM_WRITE_FAILED:         return "eeprom write failed";

  0006a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BE@KJGDCNBK@eeprom?5write?5failed?$AA@

; 38   : }

  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN6@GetErrorMs:

; 30   :     case FT_EEPROM_ERASE_FAILED:         return "eeprom erase failed";

  00071	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BE@CFCHMELH@eeprom?5erase?5failed?$AA@

; 38   : }

  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
$LN5@GetErrorMs:

; 31   : 	case FT_EEPROM_NOT_PRESENT:          return "eeprom not present";

  00078	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BD@JKEPJBHF@eeprom?5not?5present?$AA@

; 38   : }

  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
$LN4@GetErrorMs:

; 32   : 	case FT_EEPROM_NOT_PROGRAMMED:       return "eeprom not programmed";

  0007f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BG@JMCJFOE@eeprom?5not?5programmed?$AA@

; 38   : }

  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
$LN3@GetErrorMs:

; 33   : 	case FT_INVALID_ARGS:                return "invalid args";

  00086	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@LBHEEELJ@invalid?5args?$AA@

; 38   : }

  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN2@GetErrorMs:

; 34   : 	case FT_NOT_SUPPORTED:               return "not supported";

  0008d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0O@NHEDABJP@not?5supported?$AA@

; 38   : }

  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN1@GetErrorMs:

; 35   : 	case FT_OTHER_ERROR:                 return "other error";

  00094	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0M@CBIEBGLO@other?5error?$AA@

; 38   : }

  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
$LN20@GetErrorMs:

; 36   : 	}
; 37   : 	return "unknown error";

  0009b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@

; 38   : }

  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
  000a2	8b ff		 npad	 2
$LN24@GetErrorMs:
  000a4	00 00 00 00	 DD	 $LN19@GetErrorMs
  000a8	00 00 00 00	 DD	 $LN18@GetErrorMs
  000ac	00 00 00 00	 DD	 $LN17@GetErrorMs
  000b0	00 00 00 00	 DD	 $LN16@GetErrorMs
  000b4	00 00 00 00	 DD	 $LN15@GetErrorMs
  000b8	00 00 00 00	 DD	 $LN14@GetErrorMs
  000bc	00 00 00 00	 DD	 $LN13@GetErrorMs
  000c0	00 00 00 00	 DD	 $LN12@GetErrorMs
  000c4	00 00 00 00	 DD	 $LN11@GetErrorMs
  000c8	00 00 00 00	 DD	 $LN10@GetErrorMs
  000cc	00 00 00 00	 DD	 $LN9@GetErrorMs
  000d0	00 00 00 00	 DD	 $LN8@GetErrorMs
  000d4	00 00 00 00	 DD	 $LN7@GetErrorMs
  000d8	00 00 00 00	 DD	 $LN6@GetErrorMs
  000dc	00 00 00 00	 DD	 $LN5@GetErrorMs
  000e0	00 00 00 00	 DD	 $LN4@GetErrorMs
  000e4	00 00 00 00	 DD	 $LN3@GetErrorMs
  000e8	00 00 00 00	 DD	 $LN2@GetErrorMs
  000ec	00 00 00 00	 DD	 $LN1@GetErrorMs
?GetErrorMsg@CUSB@@SAPBDH@Z ENDP			; CUSB::GetErrorMsg
_TEXT	ENDS
PUBLIC	?EnumFirst@CUSB@@QAE_NAAI@Z			; CUSB::EnumFirst
EXTRN	__imp__FT_ListDevices@12:PROC
; Function compile flags: /Ogtp
;	COMDAT ?EnumFirst@CUSB@@QAE_NAAI@Z
_TEXT	SEGMENT
_nDevices$ = 8						; size = 4
?EnumFirst@CUSB@@QAE_NAAI@Z PROC			; CUSB::EnumFirst, COMDAT
; _this$ = ecx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 43   : 	ftStatus = FT_ListDevices(&enumCount,
; 44   : 		NULL,FT_LIST_NUMBER_ONLY|FT_OPEN_BY_SERIAL_NUMBER);

  00005	68 01 00 00 80	 push	 -2147483647		; 80000001H
  0000a	8b f1		 mov	 esi, ecx
  0000c	6a 00		 push	 0
  0000e	8d 7e 14	 lea	 edi, DWORD PTR [esi+20]
  00011	57		 push	 edi
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_ListDevices@12
  00018	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 45   : 	if (ftStatus != FT_OK)

  0001b	85 c0		 test	 eax, eax
  0001d	74 1e		 je	 SHORT $LN1@EnumFirst

; 46   : 	{
; 47   : 		nDevices = enumCount = enumPos = 0;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _nDevices$[ebp]
  00022	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00028	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002f	5f		 pop	 edi
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 48   : 		return false;

  00036	32 c0		 xor	 al, al
  00038	5e		 pop	 esi

; 54   : }

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN1@EnumFirst:

; 49   : 	}
; 50   : 
; 51   : 	nDevices = enumCount;

  0003d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0003f	8b 55 08	 mov	 edx, DWORD PTR _nDevices$[ebp]
  00042	89 0a		 mov	 DWORD PTR [edx], ecx
  00044	5f		 pop	 edi

; 52   : 	enumPos = 0;

  00045	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 53   : 	return true;

  0004c	b0 01		 mov	 al, 1
  0004e	5e		 pop	 esi

; 54   : }

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?EnumFirst@CUSB@@QAE_NAAI@Z ENDP			; CUSB::EnumFirst
_TEXT	ENDS
PUBLIC	?EnumNext@CUSB@@QAE_NQAD@Z			; CUSB::EnumNext
; Function compile flags: /Ogtp
;	COMDAT ?EnumNext@CUSB@@QAE_NQAD@Z
_TEXT	SEGMENT
_name$ = 8						; size = 4
?EnumNext@CUSB@@QAE_NQAD@Z PROC				; CUSB::EnumNext, COMDAT
; _this$ = ecx

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 59   : 	if (enumPos >= enumCount) return false;

  00006	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00009	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  0000c	73 1f		 jae	 SHORT $LN5@EnumNext

; 60   : 	ftStatus = FT_ListDevices((PVOID)enumPos, name, FT_LIST_BY_INDEX);

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _name$[ebp]
  00011	68 00 00 00 40	 push	 1073741824		; 40000000H
  00016	51		 push	 ecx
  00017	50		 push	 eax
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_ListDevices@12

; 61   : 	if (ftStatus != FT_OK)

  0001e	33 c9		 xor	 ecx, ecx
  00020	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00023	3b c1		 cmp	 eax, ecx
  00025	74 0d		 je	 SHORT $LN1@EnumNext

; 62   : 	{
; 63   : 		enumCount = enumPos = 0;

  00027	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0002a	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
$LN5@EnumNext:

; 64   : 		return false;

  0002d	32 c0		 xor	 al, al
  0002f	5e		 pop	 esi

; 68   : 	return true;
; 69   : }

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN1@EnumNext:

; 65   : 	}
; 66   : 
; 67   : 	enumPos++;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	01 46 10	 add	 DWORD PTR [esi+16], eax
  0003c	5e		 pop	 esi

; 68   : 	return true;
; 69   : }

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?EnumNext@CUSB@@QAE_NQAD@Z ENDP				; CUSB::EnumNext
_TEXT	ENDS
PUBLIC	?Enum@CUSB@@QAE_NQADI@Z				; CUSB::Enum
; Function compile flags: /Ogtp
;	COMDAT ?Enum@CUSB@@QAE_NQADI@Z
_TEXT	SEGMENT
_name$ = 8						; size = 4
_pos$ = 12						; size = 4
?Enum@CUSB@@QAE_NQADI@Z PROC				; CUSB::Enum, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   : 	enumPos=pos;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 74   : 	if (enumPos >= enumCount) return false;

  0000c	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  0000f	73 1f		 jae	 SHORT $LN5@Enum

; 75   : 	ftStatus = FT_ListDevices((PVOID)enumPos, name, FT_LIST_BY_INDEX);

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _name$[ebp]
  00014	68 00 00 00 40	 push	 1073741824		; 40000000H
  00019	51		 push	 ecx
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_ListDevices@12

; 76   : 	if (ftStatus != FT_OK)

  00021	33 c9		 xor	 ecx, ecx
  00023	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00026	3b c1		 cmp	 eax, ecx
  00028	74 0d		 je	 SHORT $LN1@Enum

; 77   : 	{
; 78   : 		enumCount = enumPos = 0;

  0002a	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0002d	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
$LN5@Enum:

; 79   : 		return false;

  00030	32 c0		 xor	 al, al
  00032	5e		 pop	 esi

; 83   : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
$LN1@Enum:

; 80   : 	}
; 81   : 
; 82   : 	return true;

  00037	b0 01		 mov	 al, 1
  00039	5e		 pop	 esi

; 83   : }

  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
?Enum@CUSB@@QAE_NQADI@Z ENDP				; CUSB::Enum
_TEXT	ENDS
PUBLIC	?Open@CUSB@@QAE_NQAD@Z				; CUSB::Open
EXTRN	__imp__FT_SetTimeouts@12:PROC
EXTRN	__imp__FT_SetBitMode@12:PROC
EXTRN	__imp__FT_OpenEx@12:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Open@CUSB@@QAE_NQAD@Z
_TEXT	SEGMENT
_serialNumber$ = 8					; size = 4
?Open@CUSB@@QAE_NQAD@Z PROC				; CUSB::Open, COMDAT
; _this$ = ecx

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 88   : 	if (isUSB_open) { ftStatus = FT_DEVICE_NOT_OPENED; return false; }

  00006	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0000a	74 0e		 je	 SHORT $LN3@Open
  0000c	c7 46 0c 03 00
	00 00		 mov	 DWORD PTR [esi+12], 3
  00013	32 c0		 xor	 al, al
  00015	5e		 pop	 esi

; 176  : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN3@Open:

; 89   : 
; 90   : 	m_posR = m_sizeR = m_posW = 0;
; 91   : 
; 92   : 	ftStatus = FT_OpenEx(serialNumber, FT_OPEN_BY_SERIAL_NUMBER, &ftHandle);

  0001a	8b 45 08	 mov	 eax, DWORD PTR _serialNumber$[ebp]
  0001d	57		 push	 edi
  0001e	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  00021	57		 push	 edi
  00022	6a 01		 push	 1
  00024	50		 push	 eax
  00025	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0002c	c7 86 20 04 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1056], 0
  00036	c7 86 1c 04 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1052], 0
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_OpenEx@12
  00046	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 93   : 
; 94   : 	if (ftStatus != FT_OK)

  00049	85 c0		 test	 eax, eax

; 95   : #ifdef _WIN32
; 96   : 		return false;

  0004b	75 17		 jne	 SHORT $LN7@Open

; 97   : #else
; 98   : 	{
; 99   :         /* maybe the ftdi_sio and usbserial kernel modules are attached to the device */
; 100  :         /* try to detach them using the libusb library directly */
; 101  : 
; 102  :         /* prepare libusb structures */
; 103  :         libusb_device ** list;
; 104  :         libusb_device_handle *handle;
; 105  :         struct libusb_device_descriptor descriptor;
; 106  : 
; 107  :         /* initialise libusb and get device list*/
; 108  :         libusb_init(NULL);
; 109  :         ssize_t ndevices = libusb_get_device_list(NULL, &list);
; 110  :         if( ndevices < 0)
; 111  :           return false;
; 112  : 
; 113  :         char serial [20];
; 114  : 
; 115  :         bool found = false;
; 116  : 
; 117  :         /* loop over all USB devices */
; 118  :         for( int dev = 0; dev < ndevices; dev++) {
; 119  :             /* get the device descriptor */
; 120  :             int ok = libusb_get_device_descriptor(list[dev], &descriptor);
; 121  :             if( ok != 0)
; 122  :                 continue;
; 123  :             /* we're only interested in devices with one vendor and two possible product ID */
; 124  :             if( descriptor.idVendor != 0x0403 && (descriptor.idProduct != 0x6001 || descriptor.idProduct != 0x6014))
; 125  :                 continue;
; 126  : 
; 127  :             /* open the device */
; 128  :             ok = libusb_open(list[dev], &handle);
; 129  :             if( ok != 0)
; 130  :                     continue;
; 131  :             /* Read the serial number from the device */
; 132  :             ok = libusb_get_string_descriptor_ascii(handle, descriptor.iSerialNumber, (unsigned char *) serial, 20);
; 133  :             if( ok < 0)
; 134  :                 continue;
; 135  : 
; 136  :             /* Check the device serial number */
; 137  :             if( strcmp(serialNumber, serial) == 0) {
; 138  :                 /* that's our device */
; 139  :                 found = true;
; 140  : 
; 141  :                 /* Detach the kernel module from the device */
; 142  :                 ok = libusb_detach_kernel_driver(handle, 0);
; 143  :                 if( ok == 0)
; 144  :                     printf("Detached kernel driver from selected testboard.\n");
; 145  :                 else
; 146  :                     printf("Unable to detach kernel driver from selected testboard.\n");
; 147  :                 break;
; 148  :             }
; 149  : 
; 150  :             libusb_close(handle);
; 151  :         }
; 152  : 
; 153  :         libusb_free_device_list(list, 1);
; 154  : 
; 155  :         /* if the device was not found in the previous loop, don't try again */
; 156  :         if( !found)
; 157  :             return false;
; 158  : 
; 159  :         /* try to re-open with the detached device */
; 160  :         ftStatus = FT_OpenEx(serialNumber, FT_OPEN_BY_SERIAL_NUMBER, &ftHandle);
; 161  :         if( ftStatus != FT_OK)
; 162  :             return false;
; 163  :     }
; 164  : #endif
; 165  : 
; 166  : 
; 167  : 	ftStatus = FT_SetBitMode(ftHandle, 0xFF, 0x40);

  0004d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0004f	6a 40		 push	 64			; 00000040H
  00051	68 ff 00 00 00	 push	 255			; 000000ffH
  00056	51		 push	 ecx
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_SetBitMode@12
  0005d	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 168  : 	if (ftStatus != FT_OK) return false;

  00060	85 c0		 test	 eax, eax
  00062	74 08		 je	 SHORT $LN1@Open
$LN7@Open:
  00064	5f		 pop	 edi
  00065	32 c0		 xor	 al, al
  00067	5e		 pop	 esi

; 176  : }

  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
$LN1@Open:

; 169  : 
; 170  : //	FT_SetUSBParameters(ftHandle, 8192, 8192);
; 171  : //	FT_SetBaudRate(ftHandle, 9600);
; 172  : 	
; 173  : 	FT_SetTimeouts(ftHandle,4000,1000);

  0006c	8b 17		 mov	 edx, DWORD PTR [edi]
  0006e	68 e8 03 00 00	 push	 1000			; 000003e8H
  00073	68 a0 0f 00 00	 push	 4000			; 00000fa0H
  00078	52		 push	 edx
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_SetTimeouts@12
  0007f	5f		 pop	 edi

; 174  : 	isUSB_open = true;

  00080	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1

; 175  : 	return true;

  00084	b0 01		 mov	 al, 1
  00086	5e		 pop	 esi

; 176  : }

  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?Open@CUSB@@QAE_NQAD@Z ENDP				; CUSB::Open
_TEXT	ENDS
PUBLIC	?Close@CUSB@@UAEXXZ				; CUSB::Close
EXTRN	__imp__FT_Close@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Close@CUSB@@UAEXXZ
_TEXT	SEGMENT
?Close@CUSB@@UAEXXZ PROC				; CUSB::Close, COMDAT
; _this$ = ecx

; 180  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 181  : 	if (!isUSB_open) return;

  00003	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00007	74 0e		 je	 SHORT $LN2@Close

; 182  : 	FT_Close(ftHandle);

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_Close@4

; 183  : 	isUSB_open = 0;

  00013	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
$LN2@Close:
  00017	5e		 pop	 esi

; 184  : }

  00018	c3		 ret	 0
?Close@CUSB@@UAEXXZ ENDP				; CUSB::Close
_TEXT	ENDS
PUBLIC	__TI1?AVCRpcError@@
PUBLIC	?Write@CUSB@@UAEXPBXI@Z				; CUSB::Write
PUBLIC	__CTA1?AVCRpcError@@
PUBLIC	__CT??_R0?AVCRpcError@@@88
PUBLIC	??_R0?AVCRpcError@@@8				; CRpcError `RTTI Type Descriptor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R0?AVCRpcError@@@8
; File c:\users\erich\documents\college\dtb_project\psi46test-master\psi46test-master\rpc_error.h
_DATA	SEGMENT
??_R0?AVCRpcError@@@8 DD FLAT:??_7type_info@@6B@	; CRpcError `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCRpcError@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVCRpcError@@@88
xdata$x	SEGMENT
__CT??_R0?AVCRpcError@@@88 DD 00H
	DD	FLAT:??_R0?AVCRpcError@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	08H
	DD	00H
xdata$x	ENDS
;	COMDAT __CTA1?AVCRpcError@@
xdata$x	SEGMENT
__CTA1?AVCRpcError@@ DD 01H
	DD	FLAT:__CT??_R0?AVCRpcError@@@88
xdata$x	ENDS
;	COMDAT __TI1?AVCRpcError@@
xdata$x	SEGMENT
__TI1?AVCRpcError@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCRpcError@@
; Function compile flags: /Ogtp
; File c:\users\erich\documents\college\dtb_project\psi46test-master\psi46test-master\usb.cpp
xdata$x	ENDS
;	COMDAT ?Write@CUSB@@UAEXPBXI@Z
_TEXT	SEGMENT
$T127326 = -8						; size = 8
$T127325 = -8						; size = 8
_buffer$ = 8						; size = 4
_bytesToWrite$ = 12					; size = 4
?Write@CUSB@@UAEXPBXI@Z PROC				; CUSB::Write, COMDAT
; _this$ = ecx

; 188  : { PROFILING

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 189  : 	if (!isUSB_open) throw CRpcError(CRpcError::WRITE_ERROR);

  0000a	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0000e	57		 push	 edi
  0000f	75 1c		 jne	 SHORT $LN5@Write
  00011	b8 02 00 00 00	 mov	 eax, 2
  00016	89 45 f8	 mov	 DWORD PTR $T127325[ebp], eax
  00019	8b 45 fc	 mov	 eax, DWORD PTR $T127326[ebp+4]
  0001c	68 00 00 00 00	 push	 OFFSET __TI1?AVCRpcError@@
  00021	8d 4d f8	 lea	 ecx, DWORD PTR $T127325[ebp]
  00024	51		 push	 ecx
  00025	89 45 fc	 mov	 DWORD PTR $T127325[ebp+4], eax
  00028	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@Write:
$LN5@Write:

; 190  : 
; 191  : 	DWORD k=0;
; 192  : 	for (k=0; k < bytesToWrite; k++)

  0002d	8b 5d 0c	 mov	 ebx, DWORD PTR _bytesToWrite$[ebp]
  00030	33 ff		 xor	 edi, edi
  00032	85 db		 test	 ebx, ebx
  00034	74 27		 je	 SHORT $LN2@Write
$LL4@Write:

; 193  : 	{
; 194  : 		if (m_posW >= USBWRITEBUFFERSIZE) Flush();

  00036	81 7e 18 00 04
	00 00		 cmp	 DWORD PTR [esi+24], 1024 ; 00000400H
  0003d	72 09		 jb	 SHORT $LN1@Write
  0003f	8b 16		 mov	 edx, DWORD PTR [esi]
  00041	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00044	8b ce		 mov	 ecx, esi
  00046	ff d0		 call	 eax
$LN1@Write:

; 195  : 		m_bufferW[m_posW++] = ((unsigned char*)buffer)[k];

  00048	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  0004b	8a 04 17	 mov	 al, BYTE PTR [edi+edx]
  0004e	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00051	88 44 31 1c	 mov	 BYTE PTR [ecx+esi+28], al
  00055	ff 46 18	 inc	 DWORD PTR [esi+24]
  00058	47		 inc	 edi
  00059	3b fb		 cmp	 edi, ebx
  0005b	72 d9		 jb	 SHORT $LL4@Write
$LN2@Write:
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 196  : 	}
; 197  : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 08 00	 ret	 8
$LN12@Write:
?Write@CUSB@@UAEXPBXI@Z ENDP				; CUSB::Write
_TEXT	ENDS
PUBLIC	?Flush@CUSB@@UAEXXZ				; CUSB::Flush
EXTRN	__imp__FT_Write@16:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Flush@CUSB@@UAEXXZ
_TEXT	SEGMENT
$T127342 = -12						; size = 8
$T127341 = -12						; size = 8
$T127340 = -12						; size = 8
$T127339 = -12						; size = 8
$T127338 = -12						; size = 8
$T127337 = -12						; size = 8
_bytesWritten$ = -4					; size = 4
?Flush@CUSB@@UAEXXZ PROC				; CUSB::Flush, COMDAT
; _this$ = ecx

; 201  : { PROFILING

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 202  : 	DWORD bytesWritten;
; 203  : 	DWORD bytesToWrite = m_posW;
; 204  : 	m_posW = 0;
; 205  : 
; 206  : 	if (!isUSB_open) throw CRpcError(CRpcError::WRITE_ERROR);

  00009	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0000d	57		 push	 edi
  0000e	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  00011	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  00018	75 1c		 jne	 SHORT $LN4@Flush
  0001a	b8 02 00 00 00	 mov	 eax, 2
  0001f	89 45 f4	 mov	 DWORD PTR $T127337[ebp], eax
  00022	8b 45 f8	 mov	 eax, DWORD PTR $T127338[ebp+4]
  00025	68 00 00 00 00	 push	 OFFSET __TI1?AVCRpcError@@
  0002a	8d 4d f4	 lea	 ecx, DWORD PTR $T127337[ebp]
  0002d	51		 push	 ecx
  0002e	89 45 f8	 mov	 DWORD PTR $T127337[ebp+4], eax
  00031	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@Flush:
$LN4@Flush:

; 207  : 
; 208  : 	if (!bytesToWrite) return;

  00036	85 ff		 test	 edi, edi
  00038	74 5e		 je	 SHORT $LN1@Flush

; 209  : 
; 210  : 	ftStatus = FT_Write(ftHandle, m_bufferW, bytesToWrite, &bytesWritten);

  0003a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003d	8d 55 fc	 lea	 edx, DWORD PTR _bytesWritten$[ebp]
  00040	52		 push	 edx
  00041	57		 push	 edi
  00042	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  00045	50		 push	 eax
  00046	51		 push	 ecx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_Write@16
  0004d	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 211  : 
; 212  : 	if (ftStatus != FT_OK) throw CRpcError(CRpcError::WRITE_ERROR);

  00050	85 c0		 test	 eax, eax
  00052	74 1c		 je	 SHORT $LN2@Flush
  00054	8b 55 f8	 mov	 edx, DWORD PTR $T127340[ebp+4]
  00057	b8 02 00 00 00	 mov	 eax, 2
  0005c	89 45 f4	 mov	 DWORD PTR $T127339[ebp], eax
  0005f	68 00 00 00 00	 push	 OFFSET __TI1?AVCRpcError@@
  00064	8d 45 f4	 lea	 eax, DWORD PTR $T127339[ebp]
  00067	50		 push	 eax
  00068	89 55 f8	 mov	 DWORD PTR $T127339[ebp+4], edx
  0006b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN15@Flush:
$LN2@Flush:

; 213  : 	if (bytesWritten != bytesToWrite) { ftStatus = FT_IO_ERROR; throw CRpcError(CRpcError::WRITE_ERROR); }

  00070	39 7d fc	 cmp	 DWORD PTR _bytesWritten$[ebp], edi
  00073	74 23		 je	 SHORT $LN1@Flush
  00075	8b 4d f8	 mov	 ecx, DWORD PTR $T127342[ebp+4]
  00078	68 00 00 00 00	 push	 OFFSET __TI1?AVCRpcError@@
  0007d	8d 55 f4	 lea	 edx, DWORD PTR $T127341[ebp]
  00080	b8 02 00 00 00	 mov	 eax, 2
  00085	52		 push	 edx
  00086	c7 46 0c 04 00
	00 00		 mov	 DWORD PTR [esi+12], 4
  0008d	89 45 f4	 mov	 DWORD PTR $T127341[ebp], eax
  00090	89 4d f8	 mov	 DWORD PTR $T127341[ebp+4], ecx
  00093	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN16@Flush:
$LN1@Flush:
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi

; 214  : }

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
$LN13@Flush:
?Flush@CUSB@@UAEXXZ ENDP				; CUSB::Flush
_TEXT	ENDS
PUBLIC	?FillBuffer@CUSB@@AAE_NK@Z			; CUSB::FillBuffer
EXTRN	__imp__FT_Read@16:PROC
EXTRN	__imp__FT_GetQueueStatus@8:PROC
; Function compile flags: /Ogtp
;	COMDAT ?FillBuffer@CUSB@@AAE_NK@Z
_TEXT	SEGMENT
_bytesAvailable$ = -4					; size = 4
_minBytesToRead$ = 8					; size = 4
?FillBuffer@CUSB@@AAE_NK@Z PROC				; CUSB::FillBuffer, COMDAT
; _this$ = ecx

; 218  : { PROFILING

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 219  : 	if (!isUSB_open) return false;

  00007	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0000b	75 09		 jne	 SHORT $LN5@FillBuffer
$LN12@FillBuffer:
  0000d	32 c0		 xor	 al, al
  0000f	5e		 pop	 esi

; 239  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN5@FillBuffer:

; 220  : 
; 221  : 	DWORD bytesAvailable, bytesToRead;
; 222  : 
; 223  : 	ftStatus = FT_GetQueueStatus(ftHandle, &bytesAvailable);

  00016	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00019	8d 45 fc	 lea	 eax, DWORD PTR _bytesAvailable$[ebp]
  0001c	50		 push	 eax
  0001d	51		 push	 ecx
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_GetQueueStatus@8
  00024	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 224  : 	if (ftStatus != FT_OK) return false;

  00027	85 c0		 test	 eax, eax
  00029	75 e2		 jne	 SHORT $LN12@FillBuffer

; 225  : 
; 226  : 	if (m_posR<m_sizeR) return false;

  0002b	8b 96 1c 04 00
	00		 mov	 edx, DWORD PTR [esi+1052]
  00031	3b 96 20 04 00
	00		 cmp	 edx, DWORD PTR [esi+1056]
  00037	57		 push	 edi
  00038	8d be 20 04 00
	00		 lea	 edi, DWORD PTR [esi+1056]
  0003e	72 42		 jb	 SHORT $LN11@FillBuffer

; 227  : 
; 228  : 	bytesToRead = (bytesAvailable>minBytesToRead)? bytesAvailable : minBytesToRead;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _bytesAvailable$[ebp]
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _minBytesToRead$[ebp]
  00046	3b c1		 cmp	 eax, ecx
  00048	77 02		 ja	 SHORT $LN9@FillBuffer
  0004a	8b c1		 mov	 eax, ecx
$LN9@FillBuffer:

; 229  : 	if (bytesToRead>USBREADBUFFERSIZE) bytesToRead = USBREADBUFFERSIZE;

  0004c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00051	76 05		 jbe	 SHORT $LN2@FillBuffer
  00053	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
$LN2@FillBuffer:

; 230  : 
; 231  : 	ftStatus = FT_Read(ftHandle, m_bufferR, bytesToRead, &m_sizeR);

  00058	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0005b	57		 push	 edi
  0005c	50		 push	 eax
  0005d	8d 86 24 04 00
	00		 lea	 eax, DWORD PTR [esi+1060]
  00063	50		 push	 eax
  00064	51		 push	 ecx
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_Read@16
  0006b	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 232  : 	m_posR = 0;

  0006e	c7 86 1c 04 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1052], 0

; 233  : 	if (ftStatus != FT_OK)

  00078	85 c0		 test	 eax, eax
  0007a	74 10		 je	 SHORT $LN1@FillBuffer

; 234  : 	{
; 235  : 		m_sizeR = 0;

  0007c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN11@FillBuffer:
  00082	5f		 pop	 edi

; 236  : 		return false;

  00083	32 c0		 xor	 al, al
  00085	5e		 pop	 esi

; 239  : }

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
$LN1@FillBuffer:
  0008c	5f		 pop	 edi

; 237  : 	}
; 238  : 	return true;

  0008d	b0 01		 mov	 al, 1
  0008f	5e		 pop	 esi

; 239  : }

  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?FillBuffer@CUSB@@AAE_NK@Z ENDP				; CUSB::FillBuffer
_TEXT	ENDS
PUBLIC	?Read@CUSB@@UAEXPAXI@Z				; CUSB::Read
; Function compile flags: /Ogtp
;	COMDAT ?Read@CUSB@@UAEXPAXI@Z
_TEXT	SEGMENT
$T127372 = -8						; size = 8
$T127371 = -8						; size = 8
$T127370 = -8						; size = 8
$T127369 = -8						; size = 8
$T127366 = -8						; size = 8
$T127365 = -8						; size = 8
_buffer$ = 8						; size = 4
_bytesToRead$ = 12					; size = 4
?Read@CUSB@@UAEXPAXI@Z PROC				; CUSB::Read, COMDAT
; _this$ = ecx

; 243  : { PROFILING

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 244  : 	if (!isUSB_open) throw CRpcError(CRpcError::READ_ERROR);

  0000a	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0000e	57		 push	 edi
  0000f	75 1c		 jne	 SHORT $LN11@Read
$LN23@Read:
  00011	b8 03 00 00 00	 mov	 eax, 3
  00016	89 45 f8	 mov	 DWORD PTR $T127365[ebp], eax
  00019	8b 45 fc	 mov	 eax, DWORD PTR $T127366[ebp+4]
  0001c	68 00 00 00 00	 push	 OFFSET __TI1?AVCRpcError@@
  00021	8d 4d f8	 lea	 ecx, DWORD PTR $T127365[ebp]
  00024	51		 push	 ecx
  00025	89 45 fc	 mov	 DWORD PTR $T127365[ebp+4], eax
  00028	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN28@Read:
$LN11@Read:

; 245  : 
; 246  : 	DWORD i;
; 247  : 
; 248  : 	for (i=0; i<bytesToRead; i++)

  0002d	8b 7d 0c	 mov	 edi, DWORD PTR _bytesToRead$[ebp]
  00030	33 db		 xor	 ebx, ebx
  00032	85 ff		 test	 edi, edi
  00034	74 71		 je	 SHORT $LN8@Read
  00036	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL10@Read:

; 249  : 	{
; 250  : 		if (m_posR<m_sizeR)

  00040	8b 86 1c 04 00
	00		 mov	 eax, DWORD PTR [esi+1052]
  00046	3b 86 20 04 00
	00		 cmp	 eax, DWORD PTR [esi+1056]
  0004c	73 0f		 jae	 SHORT $LN7@Read

; 251  : 			((unsigned char*)buffer)[i] = m_bufferR[m_posR++];

  0004e	8a 94 30 24 04
	00 00		 mov	 dl, BYTE PTR [eax+esi+1060]
  00055	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00058	88 14 03	 mov	 BYTE PTR [ebx+eax], dl

; 252  : 
; 253  : 		else

  0005b	eb 3f		 jmp	 SHORT $LN27@Read
$LN7@Read:

; 254  : 		{
; 255  : 			DWORD n = bytesToRead-i;

  0005d	2b fb		 sub	 edi, ebx

; 256  : 			if (n>USBREADBUFFERSIZE) n = USBREADBUFFERSIZE;

  0005f	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  00065	76 05		 jbe	 SHORT $LN5@Read
  00067	bf 00 10 00 00	 mov	 edi, 4096		; 00001000H
$LN5@Read:

; 257  : 
; 258  : 			if (!FillBuffer(n)) throw CRpcError(CRpcError::READ_ERROR);

  0006c	57		 push	 edi
  0006d	8b ce		 mov	 ecx, esi
  0006f	e8 00 00 00 00	 call	 ?FillBuffer@CUSB@@AAE_NK@Z ; CUSB::FillBuffer
  00074	84 c0		 test	 al, al
  00076	74 99		 je	 SHORT $LN23@Read

; 259  : 			if (m_sizeR < n) throw CRpcError(CRpcError::READ_ERROR);

  00078	8b 8e 20 04 00
	00		 mov	 ecx, DWORD PTR [esi+1056]
  0007e	3b cf		 cmp	 ecx, edi
  00080	72 2e		 jb	 SHORT $LN24@Read

; 260  : 
; 261  : 			if (m_posR<m_sizeR)

  00082	8b 86 1c 04 00
	00		 mov	 eax, DWORD PTR [esi+1052]
  00088	3b c1		 cmp	 eax, ecx
  0008a	73 40		 jae	 SHORT $LN2@Read

; 262  : 				((unsigned char*)buffer)[i] = m_bufferR[m_posR++];

  0008c	8a 8c 30 24 04
	00 00		 mov	 cl, BYTE PTR [eax+esi+1060]
  00093	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00096	8b 7d 0c	 mov	 edi, DWORD PTR _bytesToRead$[ebp]
  00099	88 0c 13	 mov	 BYTE PTR [ebx+edx], cl
$LN27@Read:
  0009c	ff 86 1c 04 00
	00		 inc	 DWORD PTR [esi+1052]
  000a2	43		 inc	 ebx
  000a3	3b df		 cmp	 ebx, edi
  000a5	72 99		 jb	 SHORT $LL10@Read
$LN8@Read:
  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx

; 266  : 			}
; 267  : 		}
; 268  : 	}
; 269  : }

  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c2 08 00	 ret	 8
$LN24@Read:

; 259  : 			if (m_sizeR < n) throw CRpcError(CRpcError::READ_ERROR);

  000b0	8b 55 fc	 mov	 edx, DWORD PTR $T127370[ebp+4]
  000b3	b8 03 00 00 00	 mov	 eax, 3
  000b8	89 45 f8	 mov	 DWORD PTR $T127369[ebp], eax
  000bb	68 00 00 00 00	 push	 OFFSET __TI1?AVCRpcError@@
  000c0	8d 45 f8	 lea	 eax, DWORD PTR $T127369[ebp]
  000c3	50		 push	 eax
  000c4	89 55 fc	 mov	 DWORD PTR $T127369[ebp+4], edx
  000c7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN29@Read:
$LN2@Read:

; 263  : 			else
; 264  : 			{   // timeout (bytesRead < bytesToRead)
; 265  : 				throw CRpcError(CRpcError::READ_TIMEOUT);

  000cc	8b 4d fc	 mov	 ecx, DWORD PTR $T127372[ebp+4]
  000cf	68 00 00 00 00	 push	 OFFSET __TI1?AVCRpcError@@
  000d4	8d 55 f8	 lea	 edx, DWORD PTR $T127371[ebp]
  000d7	b8 04 00 00 00	 mov	 eax, 4
  000dc	52		 push	 edx
  000dd	89 45 f8	 mov	 DWORD PTR $T127371[ebp], eax
  000e0	89 4d fc	 mov	 DWORD PTR $T127371[ebp+4], ecx
  000e3	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN30@Read:
$LN26@Read:
  000e8	cc		 int	 3
?Read@CUSB@@UAEXPAXI@Z ENDP				; CUSB::Read
_TEXT	ENDS
PUBLIC	?Clear@CUSB@@UAEXXZ				; CUSB::Clear
EXTRN	__imp__FT_Purge@8:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Clear@CUSB@@UAEXXZ
_TEXT	SEGMENT
?Clear@CUSB@@UAEXXZ PROC				; CUSB::Clear, COMDAT
; _this$ = ecx

; 273  : { PROFILING

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 274  : 	if (!isUSB_open) return;

  00003	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00007	74 2a		 je	 SHORT $LN2@Clear

; 275  : 
; 276  : 	ftStatus = FT_Purge(ftHandle, FT_PURGE_RX|FT_PURGE_TX);

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	6a 03		 push	 3
  0000e	50		 push	 eax
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_Purge@8
  00015	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 277  : 	m_posR = m_sizeR = 0;

  00018	c7 86 20 04 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1056], 0
  00022	c7 86 1c 04 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1052], 0

; 278  : 	m_posW = 0;

  0002c	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN2@Clear:
  00033	5e		 pop	 esi

; 279  : }

  00034	c3		 ret	 0
?Clear@CUSB@@UAEXXZ ENDP				; CUSB::Clear
_TEXT	ENDS
END
